## Марк Лутц. Изучаем Python

### Стандартные функции

`ord('a')`   # порядковое значение кодовой точки символа Unicode
`chr(97)`

`hasattr(obj, '__dict__')
getattr(obj, 'id')`
`setattr(obj, 'id', 123)`

### Стандартные библиотеки

*pickle* — серилизация объектов
*re* — работа с регулярными выражениями

Чтобы в сеансе *python* завершить ввод составного оператора нужно дважды нажать *Enter*.
Выход из сеанса *python* в Windows осуществляется через Ctrl+Z, в Linux — через Ctrl+D.

Чтобы сохранить на экране окно командной строки Windows при выполнении файла по двойному щелчку следует в конце файла использовать функцию **input()**.
Файлы с расширением **.pyw** в Windows при запуске подавляют вывод консольного окна.

Импортирование является неявным способом выполнения кода файла. При выполнении инструкции  *import* принимающая сторона получает модуль с атрибутами, а при использовании инструкции *from … import …* — копии указанных переменных модуля. Для просмотра всех доступных имен модуля используется функция **dir(*имя модуля*)**.
Импортировать можно не только функции модуля, но и переменные модуля. Можно создать модуль, содержащий только объявления переменных.

Обычные строки в Python3 — это строки Unicode.
Для задания байтовой последовательности используется запись вида  **b'abc'**.
Срез из строки возвращает новый объект.
Двоичные файлы имеют дело со строками bytes для неформа­тированных двоичных данных. 

Функции **dir** и **help** принимают в качестве аргументов либо реальный объект, напр., строку, либо имя типа данных (вроде str, list и diet). Последняя форма возвращает тот же самый список для dir, но отображает полные сведения о типе для help, и позволяет запрашивать справку по специфическому методу через имя типа (например, справку по **str. replace**).

Синтаксис *list comprehensions* можно использовать для генерации множеств и словарей:

```python
set1 = {i for i in range(10)}
dict1 = {i: i * i for i in set1}
```

Словари являются итерируемыми объектами с методом **next()**, который возвращает последовательные ключи (поэтому работает sorted() над словарем).

Множества — неупорядоченные коллекции уникальных и неизменяемых объектов (похожи на ключи словарей без значений).

В Python типы ассоциированы с объектами, а не с переменными.

### Строки

В Python существуют три строковых типа: **str** применяется для текста Unicode (в том числе ASCII), **bytes** используется для двоичных данных (вклю­чая закодированный текст), a **bytearray** является изменяемым вариантом типа bytes. Файлы работают в двух режимах: текстовом, который представляет со­держимое как тип *str* и реализует кодировки Unicode, и двоичном, который
имеет дело с низкоуровневым типом bytes и не выполняет какую-либо трансля­цию данных.

Функция **len()** возвращает *количество символов* в строке вне зависимости от ее кодировки.



### Списки, словари, кортежи, множества

Списки представляют собой массивы ссылок на объекты.

Словари являются неупорядоченными объектами.
Ключами словаря могут быть только неизменяемые объекты.
Словарем можно имитировать список, в который можно добавлять элементы по несуществующим индексам. Разреженные матрицы фактически являются словарями с ключами-кортежами.

##### Оператор сравнения ==

Строки сравниваются лексикографически.
Списки и кортежи сравниваются путем сравнения каждого компонента слева на­право и рекурсивно для вложенных структур.
Словари считаются равными, если равны их отсортированные списки пар (ключ, значение).
Множества равны, если оба содержат одни и те же элементы.

Числа представляют собой False в случае нуля. Остальные объекты представляют собой False, если они пусты. Во всех других случаях они = True. None всегда = False.

Выражения срезов с пустыми границами ```L[:]``` копируют последовательности, делая поверхностную копию. Тот же результат достигается через ```list(L)``` или ```L.copy()```.

Множества могут содержать только неизменяемые (хэшируемые) объекты.

### Файлы

Первые два аргумента функции **open()** должны быть строками Python — имя файла и режим доступа. Необяза­тельный третий аргумент используется для управления буферизацией вывода. Если он равен нулю, то вывод не буферизируется (т. е. передается внешнему файлу немедленно при вызове метода записи).

Для чтения строк лучше всего использовать файловые итераторы: 

```python
for line in open(’myfile.txt’): 
    line.rstrip()   # удаление хвостового пробела
```

## Операторы

Имена, которые начинаются с одиночного подчеркивания (_x), не импортиру­ются оператором
```from module import *```
Имена с двумя подчеркиваниями в начале и конце (__ x__ ) являются системны­ми именами, которые имеют особый смысл для интерпретатора.

Операции inplace-изменения объектов всегда возвращают *None*, например., ```list.extend()```.

Стандартный поток вывода доступен в Python как файловый объект **sys.stdout** из встроенного модуля sys.

Общий вид вызова функции **print()**:
 ```print(object, sep=' ' ,  end='\n', file=sys.stdout, flush=Flase)```

В python отсутствует оператор аналогичный ```switch``` или ```case```. Соответствующее поведение может быть реализовано посредством ```if…elif…else``` или путем использования словаря со значениями выбора в качестве индексов.

> *Любое ненулевое число или непустой объект = True.*
> *Нулевые числа, пустые объекты и специальный объект None = False.*

Для выбора одного непустого объекта из набора нужно объединить объекты через оператор ```or```.
Выражение ```А = Y if X else Z``` эквивалентно выражению ```А = ((X and Y) or Z)```
или выражению ```А = [Z, Y][bool(Х)]``` (правда и Z, и Y всегда будут выполнены, стр.407).

В python отсутствует оператор ```do intil …```, но он может быть эмулирован конструкцией

```python
while True:
    ...
    if exitTest(): break
```

Оператор ```pass``` имеет альтернативную форму (три точки) ```…```, которая также заменяет ```None```.

> Конструкция ```else``` цикла также выполняется, если тело цикла ни разу не выполнялось, потому что в этом случае не выполняется и оператор ```break```.

Метод ```next()``` итератора генерирует исключение ```StopIteration``` при достижении конца последовательности.

Функция ```map(func, X)``` последовательно применяет функцию ```func()``` к каждому элементу объекта x, и возвращает *итератор* для полученных значений. Функция ```filter()``` также возвращает итератор для тех элементов итерируемого объекта, где условие фильтрации, выраженное заданной функцией, истинно.

### PyDoc

Увидеть строку документации можно с помощью вывода атрибута ```__doc__``` объекта. 
Список всех атрибутов объекта выводится функцией ```dir(obj)```. Чтобы отфильтровать внутренние функции, можно использовать ```[a for a in dir(X) if not a.startswith('__')]```.
Информацию о функции модуля можно получить посредством ```help(sys.getrefcount)```.
Получить справку по модулю, который не был импортирован, можно, поместив имя модуля в
кавычки: ```help (’ re ’)``` или  ```help('email.message')```.

### Области видимости

Переменные, определенные на уровне модуля становятся его атрибутами и доступны при импортировании модуля.
Все имена, определенные внутри оператора ```def```, являются локальными и перекрывают переменные уровня файла при совпадении их имен. Чтобы получить доступ к глобальной переменной уровня модуля внутри ```def```, ее нужно объявить оператором ```global```. Если нужен доступ к переменной, объявленной в вышестоящем операторе ```def```. то ее нужно объявить оператором ```nonlocal```.
Переменные появляются в области видимости *в момент присваивания*. Inplace-изменение переменной внутри оператора ```def```, которая была инициирована на уровне модуля, например, ```L.append(X)```,  возможно без ее объявления через ```global``` или ```nonlocal```, так как здесь не происходит присваивания. Т. е. использовать переменные внешних структур внутри функции можно, но для изменения этих переменных они должны быть объявлены как ```global``` или ```nonlocal```. Для поиска переменной python последовательно обходит LEGB области видимости: Local, Enclosed, Global и Build-In и останавливается, как только найдет нужное имя..

### Функции

> Если в качестве значения по умолчанию для аргумента устанавливается *изменяемый* объект, например, ```def f(x=[])```,  то он будет одним и тем же для всех вызовов функции, даже если функция изменяет этот объект.

В определениях функции аргумент ```*x``` собирает параметры функции в кортеж, а аргумент ```**kw``` — параметры, заданные в виде *имя=значение*, в словарь.

При вызовах функции параметр ```*x``` распаковывает его в кортеж *позиционных* аргументов, а ```**kw``` эквивалентен заданию в качестве *ключевых* аргументов наборов *имя=значение*.

Аргументы, указанные в определении функции после ```*x```, при вызовах могут использовать только ключевой синтаксис. Они должны предшествовать аргументу ```**kw```.

К функциям можно присоединять произвольные атрибуты, определяемые пользователем, которые будут сохраняться между вызовами функции.

Через двоеточие к аргументам функции и возвращаемому значению можно добавить аннотирование, которое сохраняется в словаре ```__annotations__```.

### Инструменты функционального программирования

> Чтобы списковое включение вместо последовательности вернуло генератор, нужно внешние квадратные скобки заменить на круглые.

Встроенная функция **```map()```** применяет указанную функцию к элементам последовательность. Если эта функция имеет несколько аргументов, то нужно передать соответствующее число последовательностей. Функция эквивалентна ```[func(x) for x in seq]```.

Встроенная функция **```filter()```** отбирает из последовательности элементы, где указанный предикат возвращает значение True. 
Она эквивалентна ```[x for x in seq if func(x)]```.

Функция **```reduce()```** из модуля _functools_ принимает итерируемый объект, а возвращает единственное значение, которое получается путем передачи элементов последовательности заданной функции двух аргументов. Одному аргументу передается результат функции на предыдущем шаге, а второму — каждый элемент последовательности, начиная со второго. Начальным значением функции принимается значение первого элемента последовательности. ```reduce()``` допускает передачу третьего аргумента, который будет являться начальным значением функции обработки, и в этом случае обрабатываться будет все элементы последовательности. Это значение также будет возвращаться, если последовательность пуста.

Общая структура списковых включений:

```python
[выражение for цель1 in seq1 if условие1
           for цель2 in seq2 if условие2
           ...
           for цельN in seqN if условиеN ]
```

## Модули и пакеты

Текущий путь поиска модулей для импортирования возвращается атрибутом ```sys.path```. Методами ```sys.path.append()``` и ```sys.path.insert90``` можно добавлять пути поиска для текущего сеанса работы.

Пространства имен модулей, созданные операциями импортирования, представляют собой словари; к ним можно обращаться через встроенный атрибут```__ dict__``` или посредством вызова функции ```dir()```.

> Оператор ```from unders import *``` загружает только имена без подчеркиваний (либо только имена, указанные в списке, определяемым переменной ```__all__``` на верхнем уровне модуля) , в то время как оператор ```import unders``` загружает все имена, включая ```_*```.

Если файл выполняется как программа, то во время старта атрибут ```name``` устанавливается в строку ```__main__```.  Если файл импортируется, то атрибут ```__ name__``` будет равен имени модуля.

## Классы

Классы в Python основаны всего на двух вещах: поиск атрибута или метода в иерархии наследования снизу вверх и особая роль объекта `self`.

> Атрибут `__dict__` класса или его экземпляра содержит словарь, ключами которого являются все имена из пространства имен данного объекта.
> Каждый экземпляр класса содержит атрибут `__class__`, который ссылается на класс объекта.
> Атрибут `__name__` возвращает название класса объекта.
> Атрибут `__bases__` возвращает кортеж ссылок на суперклассы.

Кроме стандартного способа вызова метода через экземпляр класса существует возможность его вызова через имя класса. В этом случае необходимо методу первым аргументом передать экземпляр класса, для которого осуществляется вызов.

Для строкового представления экземпляра класса следует переопределить метод `__repr__`. Функции`print()`и `str()` используют метод `__str()__`.

> Ссылка на атрибут вызывает его поиск по цепочке наследования. Присваивание атрибуту значения создает его в области видимости, которая принадлежит соответствующему объекту.
> **Важно**. Атрибут создается в момент присваивания ему значения!

Код внутри вложенного класса, в отличие от функций, никогда не ищет атрибуты в объемлющем классе. Поэтому доступ к атрибутам возможен только через уточняющий класс или экземпляр класса.

*Python имена, начинающиеся с двойного подчеркиваниями, но не заканчивающиеся ими, расширяет с целью включения имени содержащего их класса префиксом знака подчеркивания, которое делает имена уникальными при поиске в иерархии наследования и решает проблему скрытия имен родительских классов дочерними (например, имя __ X класса Spam автоматически изменяется на Spam__ X).

Методы, вызванные через имя класса (а не через его экземпляр) являются несвязными и в качестве первого аргумента требуют ссылку на экземпляр класса, на котором будет вызван метод.

#### Использование внедрения вместо наследования

В этом случае вызовы передаются вниз внедренному объекту, а не вверх методам суперкласса при наследовании. При этом объект `Manager` не является объектом `Person`.

  ``` python
class Person:
. . . тот же код, что и ранее. . .
class Manager:
def __init__ (self, name, pay) :
    self.person = Person(name, 'mgr', pay) # внедрить объект Person
def giveRaise(self, percent, bonus=.10):
    self.person.giveRaise(percent + bonus) # перехватить и делегировать
def __getattr__(self, attr):
    return getattr (self .person, attr)    # делегировать все остальные атрибуты
def __repr__(self) :
    return str (self.person)
  ```

**pickle** — сериализирует произвольные объекты Python в строку байтов и обратно.
**dbm** — реализует файловую систему с доступом по ключу для хранения строк.
**shelve** — применяет предшествующие два модуля для хранения объектов Python в файле
по *текстовому* ключу. Пример работы с хранилищем:

``` python
import shelve
db = shelve.open('persondb')
for obj in (bob, sue, tom) :
    db[obj.name] = obj     # сохраняем объект
db.close ()
```

``` python
import shelve
db = shelve.open('persondb')  # открыть хранилище shelve
len(db)                       # количество сохраненных объектов
list(db.keys)                 # список ключей объектов
```

> Для работы с восстановленными объектами нет необходимости импорта модулей, содержащих определения соответствующих классов. При сохранении посредс­твом **pickle** экземпляра класса Python записывает его атрибуты экземпляра `self` вместе с именем класса, из которого он был создан, и модуля, где класс находится. Когда объект позже извлекается из хранилища shelve и воссоздается с помощью **pickle**, то Python автоматически повторно импортирует класс и связывает с ним соответствующий экземпляр класса. Мы должны импортировать классы, только чтобы создать новые экземпляры, но не обрабатывать существующие.

Присваивания значений объектам (кроме функций) производят атрибуты данных, *разделяемые* всеми экземплярами. Присваивание атрибута экземпляру класса создает экземплярный атрибут.

Подобно тому, как функции могут присваиваться переменным и впоследствии с помощью скобок вызываться, классы также могут быть присвоены переменным, и позже с их помощью можно создавать соответствующие им экземпляры.

#### Абстрактные методы

``` pythin
from abc import ABCMeta, abstractmethod
class Super(metaclass=ABCMeta):
  @abstractmethod
  def method(self, ...) :
    pass
```

У такого абстрактного класса нельзя создать экземпляр. У подкласса нельзя создать экземпляр, если не реализован указанный абстрактный метод (стр. 2-107).

> Для проверки реализации абстрактного метода в подклассах его реализация по умолчанию может использовать оператор: `assert False, 'Метод не определен!'`, либо генерировать исключение `raise NotImplemenedError{'Метод не определен!'`.

#### Перегрузка операций

Список операторных функций — стр.125–126.
Метод `__new__()` вызывается при создании экземпляра класса перед методом `__init()__`.
Метод `__str__()`, если определена, используется в функциях `print()` и `str()`. Во всех остальных случаях для строкового представления объекта используется функция `__repr__()`.
Для сравнение используются специфичные методы, такие как `__lt__()`. 
Метод `__call__()` реализуется для построения API на основе вызова экземпляра как функции.
Метод деструктора `__ del__()`, запускается автоматически при возвращении пространства памяти, занимаемого экземпляром.
Метод `__setitem()__` используется при присваивании по индексу и в срезах. Он перехватывает *все* присвоения значений атрибутам, так, что `X.y = 5` преобразуется в `X.__setitem__('y', 5)`. Это может использоваться для проверки присваиваемых значений.
Для реализации интерфейса последовательностей необходимо реализовать в классе метод `__getitem__()`. Он вызывается для операций индексирования и срезов, а также итерации в циклах `for`. Реализовав его в классе, мы также получим поддержку всех итерационных контекстов, включая оператор `in`, списковые включения  и функцию `map()`.
Также с помощью метода `__getitem__()` можно реализовать динамически вычисляемые атрибуты (метод с названием атрибута в качестве аргумента вызывается, если атрибут не найден в цепочке наследования — для неизвестных атрибутов метод должен сгенерировать исключение `AtributeError(attribute_name)`).

##### Итераторы

На самом деле это запасной вариант — в настоящее время итерация использует методы `__iter__`(возвращает объект-итератор) и `__next()__`(должен на объекте-итераторе выпускать элементы  до возникновения исключения `StopIteration`, *глава* 20). Только при отсутствии этих методов итерирование будет реализовано с помощью `__getitem__()` (до появления исключения `IndexError`). Реализация итерирования:

* в классе определяется метод `__iter__()`, который возвращает объект-итератор;
* в классе объекта-итератора определяется метод `__next__()`, который последовательно выдает элементы последовательности и в конце генерирует исключение `StopIteration`.

Следует помнить, что любая функция, которая содержит оператор `yield`, превращается в генераторную функцию. При вызове она возвращает новый генераторный объект с автоматическим предохранением локальной области видимости и позиции в коде, автоматически созданным методом `__ iter__()` , просто возвращающим сам объект, и автоматически созданным методом `__next__()`, *стр*. 138. При этом мы получаем доступность *множества* активных итераторов. Пример:

``` python
def __iter__(self) :
  for value in range(self.start, self.stop + 1) :
    yield value ** 2
```

Хотя и `__iter__()` и `__getitem__()` могут использоваться для проверки членства, предпочтение отдается методу `__contains__()`, которая может быть использована для оптимизации поиска элемента в последовательности.

##### Фабрика для объектов

``` python
def factory(aClass, *pargs, **kwargs):  # кортеж pargs и словарь с kwargs
  return aClass(*pargs, **kwargs)
```

### Расширенные возможности классов

* Методы перехвата обращения к атрибутам  `__ getattr__()` и `__ getattribute__()` вызываются только при *явном* доступе к атрибуту и не запускаются при *неявном* обращении встроенными (или перегруженным) операциями. Также эти методы не вызываются для перегруженных операций `__X__()`, если они определены в экземпляре класса, поскольку поиск таких атрибутов начинается с класса, а не атрибута. Методы типа `X.__add__(Y)` всегда транслируются в `type(X).__add(X, Y) `, т е. являются вариантом использования несвязного метода. 
  Для встроенных методов их поиск начинается с класса, а не с экземпляра. *Стр*. 226.
* Как правило, вызов `type(obj)` дает тот же результат, что и `obj.__class__`. Сами классы *являются экземплярами* класса `type`.
* Классы сами по себе являются и типами и экземплярами — объект `type` генерирует классы как свои экземпляры.. Типы, генерирующие классы, реализуются с помощью метаклассов, которые одновременно являются и типами (т.е метаклассами), и классами. Обычно метакласс является либо самим классом `type`, либо каким-либо его подклассом.
* Все классы наследуются от `object` . Сам `type` унаследован от `object`, a `object` от `type`, хотя они представляют собой разные объекты — циклическое отношение, которое завершает объектную модель Python и происходит из того факта, что типы являются классами,  генерирующими классы.
* Порядок наследования классов задается атрибутом-кортежем `__mro__`.
* Присваивая последовательность *строковых имен* атрибутов специальному атрибуту `__ slots__` класса, можно позволить классу ограничивать набор допустимых атрибутов, которые будут иметь экземпляры этого класса. При этом данная операция не является объявлением атрибутов и использовать их можно только после присвоения им значения. Использование слотов должно быть ограничено только случаями, когда имеется большое количество экземпляров в приложении, критичном к потреблению памяти.

#### Свойства

Для создания свойства необходимо вызвать встроенную функцию `property()` и передать ей три метода доступа — обработчики операций  получения, установки и удаления, а также необязательную строку документации. Если любой из аргументов опущен или для него передается None,
то связанная с ним операция не поддерживается: `property(get_age, None, None, None)`.

#### Статические методы и методы класса

В своем определении методы класса вместо аргумента `self` используют ссылку на класс `cls`. Статические методы вообще не используют специализированных аргументов. Вызываются как через класс, так и через экземпляр класса.  Если функция будет вызываться только через имя класса, то ее вообще можно не объявлять статической (что необходимо для ее вызова через экземпляр класса).
Также статический метод может быть реализован через обычную функцию, находящуюся вне класса, поскольку имя класса будет доступно ей как глобальная переменная и такая функция сможет использовать атрибуты класса.

Другим вариантом является переопределение функции следующим образом: `func = classmethod(func)` или `func = staticmethod(func)`, что позволяет этим функциям вызываться через экземпляр класса.

## Исключения

Генерируются при возникновении ошибок в программе либо операторами `raise` или `asset`.

Определяемые пользователем исключения реализуются с помощью классов, унаследованных от встроенного класса исключения, обычно класса `Exception`.

Оператор обработки исключения:

``` python
try: ...
except IndexError: ...
except (ValueError, TypeError, NameEror): ...
except KeyError as err: ...
except: ... # все остальлные типы исключений
else: ...   # выполняется, если исключения не возникли; секция else тебует наличия except
finally:    # выполняется всегда при выходе; указывается последней
```

Инструкция, перехватывающая все исключения, кроме системных вызовов.

``` python
try: ...
except Exception:  ...
```

**Замечания**

* Если исключения не возникло, блок `else` обрабатывается до обработки блока `finally`

* После оператора `raise` может стоять как класс, так и экземпляр класса `Exception` (в первом случае экземпляр будет создан с помощью конструктора без аргументов). При вызове без параметра оператор `raise` повторно генерирует текущее активное исключение.

* В блоке `except` будут обрабатываться также все подклассы указанного исключения.

* Функция ` sys.exc_info()[0:2]` представляет класс и экземпляр исключения и может использоваться для конкретизации исключения в блоке `except`, если в нем не указан тип исключения.

* В случае перехвата исключения суперклассом в конструкции `except` фактический тип исключения можно получить из его свойства `__class__`. 

* Чтобы сохранить объект-исключение после выхода их блока `try`, нужно просто присвоить его какой-либо переменной (*стр.* 344).

* Форма оператора `raise TypeError from err` вызывает *сцепление* исключений. Это неявно происходит при возникновении нового исключения в блоке `exeption`. Для подавления сцепления исключения используется форма `raise TypeError from None`.

* Оператор `assert` фактически является условным `raise` и эквивалентен коду (флаг `__debug__` всегда устанавливается в `True`, если только файл не запускается с флагом `-O`):

  ``` python
  if __debug__:
    if not test:
      raise AssertionError(data)
  ```

#### Диспетчер контента

В операторе `with можно через запятую указывать несколько диспетчеров контента.
Как в действительности работает оператор `with выражение [as переменная]: ...`

1. Результатом вычисления выражения является объект диспетчера контекста, который обязан иметь методы `__enter__()` и `__exit__()` .
2. Вызывается метод `__enter__()` диспетчера контекста. Возвращаемое им значение присваивается переменной в конструкции `as` при ее наличии (либо отбрасывается).
3. Выполняется код блока `with`.
4. Если в блоке `with` возникает исключение, вызывается метод `__exit____(type, value, traceback)` с передачей ему деталей исключения. Это те же самые значения, которые возвращает функция `sys.exc_info()`. Если метод `__exit__()` возвращает `False`, то исключение генерируется повторно; иначе оно заканчивается (обычно исключение должно быть сгенерировано заново, чтобы оно распространилось за пределы оператора `with`).
5. Метод `__exit__()` вызывается и при отсутствии исключений, но в этом случае всем его аргументам передаются значения `None`.

## Дополнительные материалы

### Строки и последовательности байтов

Преобразование строки в тип `bytes`: `str .encode()` и `bytes (S, encoding)`.
Преобразование последовательности байт в строку: `bytes .decode()` и `str (В, encoding)`.
Если название кодировки не передается явно, по умолчанию (но не всегда!) используется `UTF-8`, поэтому всегда нужно передавать кодировку явно.

Чтобы Python распознавал строки файла скрипта в определенной кодировке нужно, чтобы кодировка задавалась в первой или второй строках файла: `# -*- coding: latin-1 -*-`.

C помощью переменной среды **`PYTHONIOENCODING`** можно устанавли­вать кодировку, используемую для текста в стандартных потоках данных — ввода, вы­вода и ошибок.

Файлы, используемые для хранения обработанных модулем ***pickle*** объектов, всегда должны открываться в *двоичном* режиме,

### Управляемые атрибуты

Можно создать методы для доступа к атрибуту и установки его значения, например, `obj.get_name()` и `obj.set_name()`, поместив в них необходимую логику. Это нужно сделать при проектировании. Для уже  созданной системы управление необходимыми атрибутами производится с помощью специальных средств.

#### Свойства

Создается присваиванием результата вызова встроенной функции `property()` атрибуту класса (аргументы функции задают обработчики доступа, изменения, удаления и строку документации):
`атрибут = property(fget, fset, fdel, doc)`.
То же самое можно реализовать с помощью декораторов:

``` python
class Person:
  def __init__ (self, name):
    self, name = name
    return self, name

  @property
  def name(self):    # name = property (name)
    """name property docs"""
    print('fetch...')
    retturn self._name

  @name.setter
  def name(self, value):  # name = name.setter(name)
    print('change...')
    self._name = value

  @name.deleter
  def name(self):   # name = name.deleter (name)
    print(’remove...’)
    del self._name
```

> Слоты и свойства не хранятся в словаре `__dict__`!

#### Дискрипторы

Для управления атрибутом *атрибуту класса* присваивается *экземпляр* класса дискриптора. Дескриптор не будет работать, если его присвоить атрибуту *экземпляра* `self`.

``` python
class Descriptor:
  """Docstring goes here"""                 # строка документации
  def __get__ (self, instance, owner): ...  # возвращает значение атрибута
  def __set__ (self, instance, value): ...  # ничего не возвращает (None)
  def__delete__(self, instance): ...        # ничего не возвращает (None)
```

Всем трем методам дескриптора передаются экземпляр класса дескриптора `self` и *экземпляр* клиентского класса `instance`, к которому присоединен экземпляр дескриптора. Метод доступа `__get__()` дополнительно принимает аргумент `owner`, указывающий класс, к которому присоединен экземпляр дескриптора (при этом аргумент `instance` для него может быть равен  `None`, когда доступ к атрибуту производился напрямую через класс владельца (`class.attr`).
Методы дескриптора для извлечения, установки и удаления атрибута автоматически запускаются, если атрибуту присвоен экземпляр класса дескриптора. Если отсутствует метод `__set__()`, то атрибуту экземпляра можно будет присвоить значение, и это имя скроет одноименный дискриптор класса — поэтому, чтобы сделать атрибут readonly в дискрипторе нужно определить метод `__set__()` с вызовом исключения.

Для хранения данных, например, значения атрибута, дескрипторы могут использовать как состояние экземпляра, так и собственное состояние (в этом случае данные будут разделяться всеми экземплярами), а также любое их сочетание. Как правило, данные для внутренней реализации дискриптора хранятся в нем самом, а данные атрибута экземпляра — в экземпляре.

> Поскольку класс дескриптора бесполезен за рамками клиентского класса, то синтаксически разумно определять его в виде класса, вложенного в клиентский класс.

#### __ getattr__ () и __ getattribute__()

Если класс определяет или наследует указанные ниже методы, то они будут автоматически запускаться, когда экземп­ляр задействован в контексте, описанном справа в комментарии:

``` python
def __getattr__(self, name):        # при извлечении неопределенных атрибутов — obj.name
def __getattribute__(self, name):   # при извлечении всех атрибутов — obj.name
def __setattr__(self, name, value): # при присваивании всех атрибутов — obj.name=value
def __delattr__(self, name):        # при удалении всех атрибутов — del obj.name
```

Эти методы являются более обобщенными, чем свойства и дескрипторы — они могут применяться для перехвата операции извлече­ния *любого* атрибута экземпляра (или даже всех), а не только одного конкретного имени.

* Метод `__getattr__()` запускается только для неопределенных атрибутов, поскольку он
  выполняется только для атрибутов, которые не хранятся в экземпляре или не
  наследуются от одного из его классов — используется он прямолинейно.
* Метод `__getattribute__()` запускается *для каждого* атрибута — при его применении важно избежать рекурсивных циклов из-за передачи суперклассу операций доступа к атрибутам.
* Метод `__setattr__()` перехватывает присвоение значения *любому* атрибуту; метод `__delattr__()` перехватывает удаление атрибута.

> Внутри метода `__getattribute__()` нельзя получать значения других атрибутов, а внутри метода `__setattr__()` нельзя атрибутам присваивать значения. Оба этих действия приведут к зацикливанию — рекурсивному вызову этих методов. Лекарства: получать доступ к атрибуту или делать присвоение ему значения через суперкласс; присваивать значение атрибуту как ключу в словаре пространств имен `__dict__` экземпляра, избежав пря­мого присваивания (получать значения через `__dict__` нельзя, т. к. получение самого атрибута `__dict__` вызовет рекурсию).
>
> Методы  `__getattr__()` и  `__getattribute__()` не перехватывают операции извлечения атрибутов для методов `__str__()`, `__add__()`, `__getitem__()`, *стр*. 484.

### Декораторы

``` python
@decorator        эквивалентно    def func(arg):
def func(arg):                      ...
  ...                             func = decorator(func)
```

Теперь при вызове функции `func` будет осуществляться обращение к объекту, возвращаемому декоратором. Он может быть любым вызываемым объектом, в т. ч. исходной  функцией. Декоратор всегда имеет только один аргумент, в который передается `func`, и возвращает объект, требующий при вызове столько же аргументов, сколько их было у декорируемой функции.

Декоратор может быть как функцией, так и классом, в котором перегружен метод `__call__()` — именно в этом методе осуществляется декорирование исходной функции.